# 多线程

传统的C++（C++11标准之前）中并没有引入线程这个概念，在C++11出来之前，如果我们想要在C++中实现多线程，需要借助操作系统平台提供的API.

---  

C++11提供了语言层面上的多线程，包含在头文件中。它解决了跨平台的问题，提供了管理线程、保护共享数据、线程间同步操作、原子操作等类。C++11 新标准中引入了5个头文件来支持多线程编程：thread、mutex、atomic、condittion_variable、future

 C++11新标准多线程支持库
* < thread > : 提供线程创建及管理的函数或类接口；
* < mutex > : 为线程提供获得独占式资源访问能力的互斥算法，保证多个线程对共享资源的同步访问；
* < condition_variable > : 允许一定量的线程等待（可以定时）被另一线程唤醒，然后再继续执行；
* < future > : 提供了一些工具来获取异步任务（即在单独的线程中启动的函数）的返回值，并捕捉其所抛出的异常；
* < atomic > : 为细粒度的原子操作（不能被处理器拆分处理的操作）提供组件，允许无锁并发编程。

## 多线程间通信方式：
（1）互斥锁

mutex;
lock_guard (在构造函数里加锁，在析构函数里解锁）
unique_lock 自动加锁、解锁
atomic 基本类型的原子操作

（2）条件变量condition_variable

关于互斥锁和条件变量：
互斥量可以保护共享数据的修改，如果线程正在等待共享数据的某个条件出现，仅用互斥量的话就需要反复对互斥对象锁定解锁，以检查值的变化，这样将频繁查询的效率非常低。
条件变量可以让等待共享数据条件的线程进入休眠，并在条件达成时唤醒等待线程，提供一种更高效的线程同步方式。条件变量一般和互斥锁同时使用，提供一种更高效的线程同步方式。

（3）信号量

（4）读写锁shared_lock。
